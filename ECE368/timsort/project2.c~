#include <stdlib.h>
#include <string.h>
#include <stdio.h>

#define MIN_RUN_SIZE 7
#define STACK_SIZE 66
void display(int list[], int length)
{
    int i;
    printf(">");
    for (i = 0; i < length; i++)
    {
        printf(" %d", list[i]);
    }
    printf("\n");
}

typedef struct {
    int *index;
    int length;
} run;

typedef struct {
    int *storage;
    run runs[STACK_SIZE];
    int stack_height;
    int *partitioned_up_to;
    int *list;
    int length;
} Sort_State;

typedef Sort_State *sort_state;
void insertion_sort(int list[], int n);
void merge(int target[], int p1[], int l1, int p2[], int l2, int storage[]);
void swap(int list[], long int left, long int right);
int partition(sort_state state);
int should_collapse(sort_state state);
void merge_collapse(sort_state state);


void sort(int list[], int n)
{
    Sort_State state;
    state.storage = malloc(sizeof(int) * n);
    state.stack_height = 0;
    state.partitioned_up_to = list;
    state.list = list;
    state.length = n;
    while(partition(&state))
    {
        while(should_collapse(&state))
        {
            merge_collapse(&state);
        }
    }
    while(state.stack_height > 1)
    {
        merge_collapse(&state);
    }
    free(state.storage);
}


void swap(int list[], long int left, long int right)
{
    int temp;
    temp = list[left];
    list[left] = list[right];
    list[right] = temp;
}

void reverse(int list[], int n)
{
    int cd = n-1;
    int i = 0;
    while(i<cd)
        {
            swap(list,i,cd);
            i++;
            cd--;
        }
}

void boost_run_length(sort_state state, run *run)
{
    int length = state->length - (run->index - state->list);
    if(length > MIN_RUN_SIZE) length = MIN_RUN_SIZE;
    insertion_sort(run->index, length);
    run->length = length;
}

int partition(sort_state state)
{
    if(state->partitioned_up_to >= state->list + state->length)
    {
        return 0;
    }
    int *start_index = state->partitioned_up_to;
    int *next_start_index = start_index + 1;
    if(next_start_index < state->list + state->length)
    {
        if(*next_start_index < *start_index)
        {
            while(next_start_index < state->list + state->length)
            {
                if(*next_start_index < *(next_start_index - 1))
                {
                    next_start_index++;
                }
                else 
                {
                    break;
                }
            }
            reverse(start_index, next_start_index - start_index);
        }
    } 
    else 
    {
        while(next_start_index < state->list + state->length)
        {
            if(*next_start_index >= *(next_start_index - 1))
            {
                next_start_index++;
            }
            else
            {
                break;
            }
        }
    }
    run run_to_add;
    run_to_add.index = start_index;
    run_to_add.length = (next_start_index - start_index);
    if(run_to_add.length < MIN_RUN_SIZE)
    {
        boost_run_length(state, &run_to_add);
    }
    state->partitioned_up_to = start_index + run_to_add.length;
    state->runs[state->stack_height] = run_to_add;
    state->stack_height++;
    return 1;
}

int should_collapse(sort_state state)
{
    if (state->stack_height <= 2)
    {
        return 0;
    }
    int h = state->stack_height - 1;
    int head_length = state->runs[h].length;
    int next_length = state->runs[h-1].length;
    return 2 * head_length > next_length;
}

void merge_collapse(sort_state state)
{
    run A = state->runs[state->stack_height - 2];
    run B = state->runs[state->stack_height - 1];
    merge(A.index, A.index, A.length, B.index, B.length, state->storage);
    state->stack_height--;
    A.length += B.length;
    state->runs[state->stack_height - 1] = A;
}

void merge(int target[], int p1[], int l1, int p2[], int l2, int storage[])
{
    int *merge_to = storage;
    int i1, i2;
    i1 = i2 = 0;
    int *next_merge_element = merge_to;

    while(i1 < l1 && i2 < l2)
    {
        if(p1[i1] <= p2[i2])
        {
            *next_merge_element = p1[i1];
            i1++;
        }
        else 
        {
            *next_merge_element = p2[i2];
            i2++;
        }
        next_merge_element++;
    }
    memcpy(next_merge_element, p1 + i1, sizeof(int) * (l1 - i1));
    memcpy(next_merge_element, p2 + i2, sizeof(int) * (l2 - i2));
    memcpy(target, merge_to, sizeof(int) * (l1 + l2));
}

void insertion_sort(int list[], int n)
{
    int i= 1;
    int j;
	while(i<n)
    {
    	j = i-1;
    	while (j >= 0 && list[j] > list[i]) 
        {
        	swap(list,j+1,j);
        	j--;
    	}
        list[j+1]=list[i];
        i++;
	}
}


